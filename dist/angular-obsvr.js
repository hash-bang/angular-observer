angular.module("angular-obsvr",[]).provider("$observeProvider",function(){var _this=this;this.observers=[],this.register=function(observer){this.observers.push(observer)},this.deregister=function(observer){var oIndex=this.observers.findIndex(function(o){return o==observer});oIndex>-1&&this.observers.splice(oIndex,1)},this.checkAll=function(_){return _this.observers.forEach(function(observer){return observer.check()})},this.$get=function(){return this}}).factory("$observe",["$observeProvider","$timeout",function($observeProvider,$timeout){var $observe=function(scope,paths,callback,params){var observe=new Object;if(observe.scope=scope,observe.paths=_.castArray(paths),observe.originalValues={},observe.deep=1,observe.selfDestruct=!0,observe.selfDestructHooks=["change","key","path"],observe.isDestoyed=!1,observe.ignoreInitial="any",observe.isInitial=!0,observe.method="setters",observe.scanKeyChange=!0,observe.hookWarnings=!0,observe.seperator=".",observe.setEqualIsChange=!1,observe.ignoreKeys=[/^\$/],observe.root=!0,!scope)throw new Error("You must specify a scope to use");if(!paths)throw new Error("You must specify a path or paths to watch");if(_.isFunction(callback)||(_.isObject(callback)||_.isNumber(callback))&&(params=callback,callback=void 0),_.isNumber(params)&&(params.deep=params),_.isObject(params)){if(_.has(params,"deep")){if(!_.isNumber(params.deep)&&params.deep!==!0)throw new Error("Deep config option either should be a maximum depth number or boolean true");observe.deep=params.deep}if(_.has(params,"root")){if(observe.root!==!0&&!_.isNumber(observe.root))throw new Error("Root must be boolean true or a number");observe.root=params.root}if(_.has(params,"ignoreInitial")){if(params.ignoreInitial!==!1&&!_.isString(params.ignoreInitial)&&!_.includes(["once","any","all"]))throw new Error('ignoreInitial must be "never", "any", "all" or boolean false');observe.ignoreInitial=params.ignoreInitial}["ignoreKeys","selfDestructHooks"].forEach(function(k){if(_.has(params,k)){if(!_.isArray(params[k]))throw new Error(k+" must be an array");observe[k]=params[k]}}),["seperator"].forEach(function(k){if(!_.isUndefined(params[k])){if(!_.isString(params[k]))throw new Error(k+" must be a string");observe[k]=params[k]}}),["selfDestruct","scanKeyChange","hookWarnings","setEqualIsChange"].forEach(function(k){if(!_.isUndefined(params[k])){if(!_.isBoolean(params[k]))throw new Error(k+" must be a boolean");observe[k]=params[k]}})}return observe.root===!0&&1==observe.paths.length&&(observe.root=observe.paths[0]),observe.get=function(path){return path&&path.length?_.get(observe.scope,_.isArray(path)?path.join(observe.seperator):path):observe.scope},observe.traverse=function(cb,path,item,depth){if(!path&&_.isUndefined(item))observe.paths.forEach(function(path){return observe.traverse(cb,path.split(observe.seperator),observe.get(path),1)});else if(_.isArray(item)){if(_.isNumber(observe.deep)&&depth>observe.deep)return;item.forEach(function(v,k){return observe.traverse(cb,(path||[]).concat([k]),v,depth?depth+1:1)})}else if(_.isObject(item)){if(_.isNumber(observe.deep)&&depth>observe.deep)return;_.keys(item).filter(function(k){return!observe.ignoreKeys.some(function(ik){return ik.test(k)})}).forEach(function(k){return observe.traverse(cb,(path||[]).concat([k]),item[k],depth?depth+1:1)})}else cb(item,path?path[path.length-1]:"",path||[])},observe.inject=function(){return"dirty"==observe.method?observe._injectDirty():"setters"==observe.method&&observe._injectSetters(),observe},observe._injectDirty=function(){observe.originalValues={},observe.traverse(function(v,k,path){_.isObject(v)?Object.defineProperty(v,"$clean",{enumerable:!1,value:!0}):_.isPlainObject(v)||(observe.originalValues[path.join(observe.seperator)]=v)})},observe._injectSetters=function(obj,path,depth){if(!obj)return void _(observe.paths).map(function(path){return path.split(observe.seperator).slice(0,-1)}).uniq().forEach(function(parentPath){var child=observe.get(parentPath);observe._injectSetters(child,parentPath,0)});if(!(_.isNumber(observe.deep)&&depth>observe.deep)){var isArray=_.isArray(obj);path||(path=[]);var inject=_(obj).mapValues(function(v,k){if(!observe.ignoreKeys.some(function(ik){return ik.test(k)})){var nodePath=path.concat([k]),nodeValue=v;return _.isObject(v)?void observe._injectSetters(v,nodePath,(depth||0)+1):{enumerable:!0,configurable:!0,get:function(){return nodeValue},set:function(v){(observe.setEqualIsChange||nodeValue!=v)&&(console.log("SET",nodePath,"NEW=",v,"OLD=",nodeValue),observe.setModified(nodePath),nodeValue=v,_.isObject(v)&&observe._injectSetters(v,nodePath,(depth||0)+1))}}}}).pickBy(function(v){return!!v}).value();return isArray&&(inject.isArray={enumerable:!1,value:!0},inject.shift={replacePrototype:!0,enumerable:!1,value:function(){var output=Array.prototype.shift.apply(this,arguments);return observe._injectSetters(this,path,(depth||0)+1),observe.setModified(path.concat([0])),output}},inject.push={replacePrototype:!0,enumerable:!1,value:function(){var output=Array.prototype.push.apply(this,arguments);return observe._injectSetters(this,path,(depth||0)+1),observe.setModified(path.concat([this.length-1])),output}},["fill","pop","reverse","sort","splice","unshift"].forEach(function(method){inject[method]={replacePrototype:!0,enumerable:!1,value:function(){var _this2=this;observe.setModified(path);var output=Array.prototype[method].apply(this,arguments);return _.forEach(this,function(c,i){return observe._injectSetters(_this2,path,(depth||0)+1)}),output}}})),inject.toObject={replacePrototype:!0,enumerable:!1,value:function(){return _.mapValues(this,function(v){return _.isObject(v)&&_.hasIn(v,"isArray")&&v.isArray?_.map(v.toObject(),function(v,k){return v}):_.isObject(v)&&_.hasIn(v,"toObject")?v.toObject():v})}},inject.toString={replacePrototype:!0,enumerable:!1,value:function(){return"Hello Angular"}},inject.$obsvr={enumerable:!1,value:!0},inject=_.pickBy(inject,function(dp,k){return!(dp.replacePrototype&&"$obsvr"in obj)}),Object.defineProperties(obj,inject),inject}},observe.markedModified={},observe.setModified=function(path){return observe.markedModified[_.isArray(path)?path.join(observe.seperator):path]=!0,observe},observe.clearModified=function(){return observe.markedModified={},observe},observe.isModified=function(path){if(path){var v=observe.get(path);return _.isObject(v)?!v.$clean:observe.originalValues[_.isArray(path)?path.join(observe.seperator):path]!=v}if("setters"==observe.method)return _.map(observe.markedModified,function(v,p){return p});var modified=_.map(observe.markedModified,function(v,p){return p});return observe.traverse(function(v,key,path){observe.isModified(path)&&modified.push(path.join(observe.seperator))}),modified},observe.check=function(){if(observe.isDestroyed)throw new Error("observer has been destroyed");if(observe.isInitial)switch(observe.ignoreInitial){case!1:case"never":observe.emit("initial",observe.get()),observe.isInitial=!1;break;case"any":if(observe.paths.some(function(p){return void 0===observe.get(p)}))return observe.emit("initial",observe.get()),observe;observe.isInitial=!1;break;case"all":if(observe.paths.every(function(p){return void 0===observe.get(p)}))return observe.emit("initial",observe.get()),observe;observe.isInitial=!1}if("setters"==observe.method&&observe.scanKeyChange){var checkKeys=function(node,path){var needInject=!1;_.forEach(node,function(v,k){_.isObject(node[k])||_.isUndefined(Object.getOwnPropertyDescriptor(node,k).value)||observe.ignoreKeys.some(function(ik){return ik.test(k)})||(console.log("MOD",path.concat([k])),observe.setModified(path.concat([k])),needInject=!0)}),needInject&&(console.log("INJECT AT",path,node),observe._injectSetters(node,path,path.length))};_(observe.paths).map(function(path){return path.split(observe.seperator).slice(0,-1)}).uniq().forEach(function(parentPath){var parent=observe.get(parentPath);checkKeys(parent,parentPath),observe.traverse(function(v,k,path){var parentPath=path.slice(0,-1),parent=observe.get(parentPath);_.isObject(parent)&&checkKeys(parent,parentPath)},parentPath,parent,0)})}var modified=observe.isModified();return modified.length&&observe.emit("change",observe.get(observe.root||void 0)),modified.forEach(function(path){var reportPath=observe.root&&path.startsWith(observe.root)?path.substr(observe.root.length+1):path;reportPath.indexOf(observe.seperator)<0&&observe.emit("key",reportPath,observe.get(path)),observe.emit("path",reportPath,observe.get(path))}),observe.clearModified(),modified.length&&observe.emit("postChange",observe.get()),observe.inject(),modified.length&&observe.emit("postInject",observe.get()),observe.emit("finally"),observe},observe.checkAll=$observeProvider.checkAll,$observeProvider.register(observe),observe.hooks={},observe.emit=function(hook){if(observe.hooks[hook]&&observe.hooks[hook].length){var args=Array.prototype.slice.call(arguments,0),hook=args.shift(),removeOnce=!1;return observe.hooks[hook].forEach(function(hook){hook.cb.apply(observe,args),hook.once&&(removeOnce=!0)}),removeOnce&&(observe.hooks[hook]=observe.hooks[hook].filter(function(hook){return!hook.once}),observe.checkSelfDestruct()),observe}},observe.on=function(hook,cb,params){return observe.hookWarnings&&"changes"==hook&&(console.warn("Call to Observer.on('changes') but that should be non-plural. Replacing with \"change\" for now but you should also change your source code"),hook="change"),observe.hooks[hook]||(observe.hooks[hook]=[]),observe.hooks[hook].push(Object.assign({},{cb:cb,once:!1},params||{})),observe},observe.once=function(hook,cb,params){return observe.on(hook,cb,Object.assign({},{once:!0},params||{}))},observe.one=observe.once,observe.off=function(hook,cb){if(observe.hooks[hook])return observe.hooks[hook]=observe.filter(function(h){return _.isFunction(cb)?h.cb==cb:h.id==cb}),observe.checkSelfDestruct(),observe},observe.destroy=function(method){$observeProvider.deregister(observe),observe.emit("destroy",method||"manual"),observe.isDestroyed=!0},observe.checkSelfDestruct=function(){return observe.selfDestruct&&observe.selfDestructHooks.every(function(hook){return!observe.hooks[hook]||!observe.hooks[hook].length})&&observe.destroy("selfDestruct"),observe},_.isFunction(callback)&&observe.on("change",callback),observe.inject(),$timeout(function(_){return observe.emit("init")}),observe};return $observe.deep=function(scope,path,callback,params){return(_.isObject(callback)||_.isNumber(callback))&&(params=callback,callback=void 0),_.isObject(params)||(params={}),params.deep=!_.isNumber(params)||params,$observe(scope,path,callback,params)},$observe.checkAll=$observeProvider.checkAll,$observe}]);